### Ex1

dataset <- read.table('nutrients.txt', header=T)

n <- dim(dataset)[1]
p <- dim(dataset)[2]


# Boxplot
x11()
boxplot(dataset, las=2, col='gold')


# Boxplot centered in the means
x11()
boxplot(scale(x=dataset,center = T, scale=F), las=2, col='gold')



dataset <- scale(dataset)  # the default command is with center=T and scale= T 
dataset <- data.frame(dataset)
# oppure centra le variabili
# dataset = data.frame(scale(data = dataset, center = T, scale = F))

# boxplot of the scaled variables 
x11()
boxplot(dataset, las=2, col='gold')


# PCA
pc.dataset <- princomp(dataset, scores=T)
pc.dataset
summary(pc.dataset)


# Explained variance
max1 = max(pc.dataset$scores)   # va bene così?
max2 = max(sapply(dataset,sd)^2)
x11()
layout(matrix(c(2,3,1,3),2,byrow=T))
plot(pc.dataset, las=2, main='Principal components', ylim=c(0,max1))
abline(h=1, col='blue')
barplot(sapply(dataset,sd)^2, las=2, main='Original Variables', ylim=c(0,max2), ylab='Variances')
plot(cumsum(pc.dataset$sd^2)/sum(pc.dataset$sd^2), type='b', axes=F, xlab='number of components', 
     ylab='contribution to the total variance', ylim=c(0,1))
abline(h=1, col='blue')
abline(h=0.8, lty=2, col='blue')  #0.8 is a good treshold
box()
axis(2,at=0:10/10,labels=0:10/10)
axis(1,at=1:ncol(dataset),labels=1:ncol(dataset),las=2)

# keep the PC in base all'elbow o a un valore di threshold o le PC che hanno
# varaibilità >1 se siamo nel caso scaled 
# in generale se sei indecisa se tenere o no una PC se è di facile interpretazione 
# puoi tenerla altrimenti meglio di no



# Matrix of the loading
load <- pc.dataset$loadings  
load


# plot only the first k PCs
k = 3
x11()
par(mar = c(1,k,0,2), mfrow = c(k,1))
for(i in 1:k) barplot(load[,i], ylim = c(-1, 1))

threshold = 0.3
k = 3 # number of PC we select
x11()
par(mar = c(1,k,0,2), mfrow = c(k,1))
for(i in 1:k) {
  barplot(ifelse(abs(load[,i]) < threshold, 0, load[,i]) , ylim = c(-1, 1))
  abline(h=0)
}
# setting a threshold make easier the interpretation



pc.dataset$sd^2/sum(pc.dataset$sd^2)

# cumulative proportion of explained variance
cumsum(pc.dataset$sd^2)/sum(pc.dataset$sd^2)

# grafico con le frecce
x11()
biplot(pc.dataset)



# Project a new cereal with 400kcal, 9g of proteins, 5g of fats,
# 100g of carbohydrates, 30g of sugar and 4g of fiber,

scores.dataset <- pc.dataset$scores
# Projection on the space generated by the first k principal components
x11(width=21, height=7)
k = 3
DATA = data.frame(400, 9 , 5, 100, 30, 4)

par(mfrow=c(2,5))
matplot(t(DATA), type='l', main = 'Data', ylim=range(DATA))
meanF <- colMeans(DATA)
matplot(meanF, type='l', main = 'First 0 PCs', lwd=2, ylim=range(DATA))
projection <- matrix(meanF, dim(DATA)[[1]], dim(DATA)[[2]], byrow=T)
for(i in 1:8)
{
  projection <- projection + scores.dataset[,i] %*% t(load[,i])
  matplot(t(projection), type='l', main = paste('First', i, 'PCs'), ylim=range(DATA))
  matplot(meanF, type='l', lwd=2, add=T)
}


   # vector in R^p 





x0 = c(400, 9 , 5, 100, 30, 4) 
# If we have run the standardized PCA: 

DATA = read.table('nutrients.txt', header=T)
mean = colMeans(DATA)
DATA.cov = cov(DATA)
x0 = (x0 - mean)/sqrt(diag(DATA.cov))

x0 %*% load[ , 1]   # projection on span(PC1)
x0 %*% load[ , 2]   # projection on span(PC2)
# ...

proj = x0 %*% load[ , 1:3]   # projection on span(PC1,...,PCk


x11()
plot(scores.dataset[,1:2])
points(proj[1], proj[2], col = 'red',pch = 19)








